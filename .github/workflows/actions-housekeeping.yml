name: Actions Housekeeping

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      keep_runs:
        description: "Keep latest completed workflow runs"
        required: false
        default: "2"
      keep_caches:
        description: "Keep latest Actions caches"
        required: false
        default: "0"

permissions:
  actions: write
  contents: read

concurrency:
  group: actions-housekeeping
  cancel-in-progress: false

jobs:
  cleanup:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Cleanup old workflow runs
        uses: actions/github-script@v7
        env:
          KEEP_RUNS: ${{ inputs.keep_runs || '2' }}
        with:
          script: |
            const parsedKeepRuns = parseInt(process.env.KEEP_RUNS || '2', 10)
            const keepRuns = Number.isNaN(parsedKeepRuns)
              ? 2
              : Math.min(Math.max(parsedKeepRuns, 1), 30)
            const owner = context.repo.owner
            const repo = context.repo.repo

            const allRuns = await github.paginate(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner, repo, per_page: 100 }
            )

            const activeRuns = allRuns.filter(run => run.status !== 'completed')
            const completedRuns = allRuns
              .filter(run => run.status === 'completed')
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))

            const deleteCandidates = completedRuns.slice(keepRuns)
            let deleted = 0
            let failed = 0

            for (const run of deleteCandidates) {
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner,
                  repo,
                  run_id: run.id,
                })
                deleted += 1
              } catch (error) {
                failed += 1
                core.warning(`Failed deleting run ${run.id}: ${error.message}`)
              }
            }

            core.notice(
              `Runs cleanup: total=${allRuns.length}, active_kept=${activeRuns.length}, completed_kept=${Math.min(completedRuns.length, keepRuns)}, deleted=${deleted}, failed=${failed}`
            )

      - name: Cleanup old Actions caches
        uses: actions/github-script@v7
        env:
          KEEP_CACHES: ${{ inputs.keep_caches || '0' }}
        with:
          script: |
            const parsedKeepCaches = parseInt(process.env.KEEP_CACHES || '0', 10)
            const keepCaches = Number.isNaN(parsedKeepCaches)
              ? 0
              : Math.min(Math.max(parsedKeepCaches, 0), 20)
            const owner = context.repo.owner
            const repo = context.repo.repo

            const allCaches = await github.paginate(
              'GET /repos/{owner}/{repo}/actions/caches',
              { owner, repo, per_page: 100 },
              (response) => response.data.actions_caches
            )

            const sortedCaches = allCaches
              .slice()
              .sort((a, b) => new Date(b.last_accessed_at) - new Date(a.last_accessed_at))

            const deleteCandidates = sortedCaches.slice(keepCaches)
            let deleted = 0
            let failed = 0
            let skippedInvalid = 0
            let deletedById = 0
            let deletedByKeyRef = 0

            for (const cache of deleteCandidates) {
              if (!cache) {
                skippedInvalid += 1
                continue
              }

              const cacheId = cache.id
              const cacheKey = cache.key
              const cacheRef = cache.ref

              try {
                if (cacheId) {
                  await github.request('DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}', {
                    owner,
                    repo,
                    cache_id: cacheId,
                  })
                  deletedById += 1
                } else if (cacheKey && cacheRef) {
                  await github.request('DELETE /repos/{owner}/{repo}/actions/caches', {
                    owner,
                    repo,
                    key: cacheKey,
                    ref: cacheRef,
                  })
                  deletedByKeyRef += 1
                } else {
                  skippedInvalid += 1
                  continue
                }
                deleted += 1
              } catch (error) {
                failed += 1
                core.warning(`Failed deleting cache id=${cacheId || '-'} key=${cacheKey || '-'} ref=${cacheRef || '-'}: ${error.message}`)
              }
            }

            core.notice(
              `Cache cleanup: total=${allCaches.length}, kept=${Math.min(allCaches.length, keepCaches)}, candidates=${deleteCandidates.length}, skipped_invalid=${skippedInvalid}, deleted=${deleted}, deleted_by_id=${deletedById}, deleted_by_key_ref=${deletedByKeyRef}, failed=${failed}`
            )
